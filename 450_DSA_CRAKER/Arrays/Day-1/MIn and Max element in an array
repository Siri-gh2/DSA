---

## Find Minimum & Maximum Element in an Array  
(and Sum of Minimum & Maximum)

**Pattern:** Single-Pass Traversal

**Idea:**
- Initialize `min` and `max` with the first element
- Traverse the array once
- Update both values whenever a smaller or larger element is found
- Sum is simply `min + max`

**Edge Cases:**
- Empty array â†’ handle separately
- Single element â†’ min = max = that element
- All elements same â†’ min and max remain same
- All negative values â†’ works normally

---

### ğŸ“Œ Problem Links
- [GeeksforGeeks â€“ Find Minimum and Maximum Element in an Array](https://www.geeksforgeeks.org/problems/find-minimum-and-maximum-element-in-an-array4428/1)
- [Code360 â€“ Sum of Max and Min](https://www.naukri.com/code360/problems/sum-of-max-and-min_1081476)

---

## ğŸ§  Concept

The goal is to find the **smallest** and **largest** elements efficiently without scanning the array multiple times.

Example:  
Input : `[3, 5, 1, 8, 2]`  
Min : `1`  
Max : `8`  
Sum : `9`

---

## ğŸ“ Approach (Single Traversal)

### ğŸ”¹ Why this works
- Every element is checked exactly once
- Avoids repeated scanning (`O(nÂ²)`)
- Optimal and interview-friendly

---

## ğŸ’» C++ Implementation â€“ Min & Max

```cpp
pair<int, int> getMinMax(vector<int>& arr) {
    int n = arr.size();

    if (n == 0)
        return {-1, -1};

    int mini = arr[0];
    int maxi = arr[0];

    for (int i = 1; i < n; i++) {
        if (arr[i] < mini)
            mini = arr[i];
        if (arr[i] > maxi)
            maxi = arr[i];
    }

    return {mini, maxi};
}
---
ğŸ’» C++ Implementation â€“ Sum of Min & Max

int sumOfMaxMin(int arr[], int n) {
    if (n == 0)
        return 0;

    int mini = arr[0];
    int maxi = arr[0];

    for (int i = 1; i < n; i++) {
        if (arr[i] < mini)
            mini = arr[i];
        if (arr[i] > maxi)
            maxi = arr[i];
    }

    return mini + maxi;
}
---
Sample Output:

Minimum = 1
Maximum = 8
Sum     = 9
---

Pattern Learned:

Single-Pass Optimization

Used in:

Min / Max problems

Range calculations

Kadaneâ€™s Algorithm

Prefix-based logic
