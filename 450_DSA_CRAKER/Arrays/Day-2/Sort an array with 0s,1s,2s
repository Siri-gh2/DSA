---

## Sort an Array of 0s, 1s, and 2s

**Pattern:** Dutch National Flag / Three-Pointer Partitioning

**Idea:**
- Maintain three regions:
  - `[0 .. l-1]` â†’ all `0`s
  - `[l .. i-1]` â†’ all `1`s
  - `[i .. r]` â†’ unknown
  - `[r+1 .. n-1]` â†’ all `2`s
- Traverse the array once
- Move elements into correct partitions using swaps

**Edge Cases:**
- Empty array â†’ no change
- All elements same â†’ no change
- Already sorted â†’ best case

---

### ğŸ“Œ Problem Links
- [Code360 â€“ Sort 0s, 1s, and 2s](https://www.naukri.com/code360/problems/sort-0-1-2_631055?topList=love-babbar-dsa-sheet-problems&utm_source=website&utm_medium=affiliate&utm_campaign=450dsatracker&leftPanelTabValue=SUBMISSION)
- [GeeksforGeeks â€“ Sort an Array of 0s, 1s and 2s](https://www.geeksforgeeks.org/problems/sort-an-array-of-0s-1s-and-2s4231/1)

---

## ğŸ§  Concept

The goal is to **sort the array containing only `0`, `1`, and `2`** without using built-in sort and in **linear time**.

We use three pointers:
- `l` (low) â†’ boundary of next `0`
- `i` (current) â†’ current element
- `r` (right) â†’ boundary of next `2`

Each element is processed once, and swaps place values into the proper section.

---

## ğŸ“ Approach (Dutch National Flag)

### ğŸ”¹ Explanation
- If `arr[i] == 0`: swap with `arr[l]`, move both `l` and `i` forward
- If `arr[i] == 1`: just move `i`
- If `arr[i] == 2`: swap with `arr[r]`, move `r` backward (donâ€™t move `i` yet)

This ensures we partition the array in **one pass**.

---

## â± Complexity Analysis

- **Time Complexity:** `O(n)`  
  Each index is visited at most once.
- **Space Complexity:** `O(1)`  
  In-place sorting without extra memory.

---

## ğŸ’» C++ Code

```cpp
class Solution {
  public:
    void sort012(vector<int>& arr) {
        // code here
        int n = arr.size();
        int l = 0, i = 0;
        int r = n - 1;

        while (i <= r) {
            if (arr[i] == 2) {
                swap(arr[i], arr[r]);
                r--;
            }
            else if (arr[i] == 0) {
                swap(arr[i], arr[l]);
                l++;
                i++;
            }
            else {
                i++;
            }
        }
    }
};

ğŸŸ¢ Sample Output
Input:  [0, 2, 1, 2, 0, 1]
Output: [0, 0, 1, 1, 2, 2]

**Pattern Learned**

Dutch National Flag Algorithm

Three-pointer partitioning

In-place linear sorting

More efficient than counting approach


Key Takeaway

When array values are from a known small set (like 0,1,2), you can use pointer partitioning to sort in O(n) time and O(1) space.
